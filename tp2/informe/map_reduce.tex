\section{Map-Reduce.}
Para la resolución de los Map-Reduce tuvimos que cargar diferentes archivos .json. Esto se realizo con las siguientes instrucciones:
\begin{lstlisting}
mongoimport --db DB --collection COLLECTION --file 
disposiciones_201*.json --jsonArray

Por ejemplo:
mongoimport --db tp2 --collection disposiciones --file 
disposiciones_2014.json --jsonArray
\end{lstlisting}

Para cargar el código desde un .js se puede hacer load("codigo.js")

\subsection{Disposiciones de tipo resolución en Abril de 2013.}
\textbf{Map:}
Si el registro dado es de tipo resolución y tiene fecha abril del 2013, Emitir("resolucion",cant=1)

\textbf{Reduce:}
Sumar los cant q nos pasan y emitir lo mismo ("resolucion",suma)

\begin{lstlisting}
var map1 = function(){
  var date = this["FechaBOJA"].split('/')
  if(this["Tipo"] == "Resoluciones" && date[1]==4 && date[2]==2013){
    emit(this["Tipo"],1)
  }
}
\end{lstlisting}

\begin{lstlisting}
var reduce1 = function(key,values){
  return Array.sum(values)
}
\end{lstlisting}

Luego llamar a la función de map-reduce de la forma:
\begin{lstlisting}
db.disposiciones.mapReduce(map1,reduce1,{out: parte2a})
\end{lstlisting}

Lo que nos devuelve:

\begin{lstlisting}
{ "_id" : "Resoluciones", "value" : 607 }
\end{lstlisting}

\subsection{Disposiciones de cada tipo.}
\textbf{Map:}
Emitir (tipo,cant=1)
\begin{lstlisting}
var map2 = function(){
	emit(this["Tipo"],1)
}

\end{lstlisting}

\textbf{Reduce:}
Sumar los cant que nos pasan y emitir lo mismo (tipo,suma)
\begin{lstlisting}
var reduce2 = function(key,values){
	return Array.sum(values)
}
\end{lstlisting}
Luego correr: 
\begin{lstlisting}
db.disposiciones.mapReduce(map2,reduce2,{out: parte2b})
\end{lstlisting}

\subsection{Fecha mas citada.}

\textbf{Map:}
Parsear la fechaBOJA y la fecha disposicion, matchearles el formato, luego:
emitir(fechaBOJA,cant=1)
emitir(fechaDisposicion,cant=1)

\begin{lstlisting}
var map3 = function(){
	var date = (this["FechaDisposicion"].split('T'))[0].
		split('-').reverse().join('/');
	emit(date,1);
	emit(this["FechaBOJA"],1);
}
\end{lstlisting}
\textbf{Reduce:}
Sumar los cant y emitir (fecha,cant)
\begin{lstlisting}
var reduce3 = function(key,values){
	return Array.sum(values)
}
\end{lstlisting}
\begin{lstlisting}
db.disposiciones.mapReduce(map3,reduce3,{out: parte2c})
\end{lstlisting}
Luego, de ese resultado nos quedamos con el máximo.
\begin{lstlisting}
db.parte2c.find().sort({value : -1}).limit(1)
\end{lstlisting}

\subsection{Mayor cantidad de páginas por cada tipo.}

\textbf{Map:} emitir(tipo,cantPaginas)
\begin{lstlisting}
var map4 = function(){
	var cantPags = this["PaginaFinal"] - this["PaginaInicial"] + 1
	emit(this["Tipo"],cantPags)
}
\end{lstlisting}
\textbf{Reduce:}
Buscar el máximo entre todos los cantPaginas que nos llega y emitir (tipo,maxCantPaginas)
\begin{lstlisting}
var reduce4 = function(key,values){
	var cantPagsMax = 0;
	for (var i=0; i < values.length; i++){
		if(values[i] > cantPagsMax){
			cantPagsMax = values[i];
		}
	}
	return(cantPagsMax);
}
\end{lstlisting}